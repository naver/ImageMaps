{"version":3,"file":"index.umd.min.js","sources":["../src/jquery.imageMaps.js"],"sourcesContent":["/* eslint-disable unicorn/prefer-switch */\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 NAVER Corp.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/**\n* ImageMaps 1.1.0\n* jquery plugin which can be partially linked to the image\n*\n* https://github.com/naver/image-maps\n* demo - https://naver.github.io/image-maps/\n*\n* Released on: July 6, 2016.\n* @module imageMaps\n*/\n\nconst shapeFaceClass = '_shape_face';\nconst shapeVertexClass = '_shape_vertex';\nconst areaClass = 'area';\n\n/**\n* @typedef {\"rect\"|\"circle\"|\"ellipse\"|\"text\"|\"image\"|\"poly\"|\n* \"polyline\"|\"polygon\"} module:imageMaps.ShapeType\n*/\n\nconst SHAPE = {\n    RECT: 'rect',\n    CIRCLE: 'circle',\n    ELLIPSE: 'ellipse',\n    TEXT: 'text',\n    IMAGE: 'image',\n    POLY: 'poly',\n    POLYLINE: 'polyline',\n    POLYGON: 'polygon'\n};\n\n/**\n * @see https://api.jquery.com/css/\n * @typedef {PlainObject<string,string>} module:imageMaps.ShapeStyles\n*/\n\n/**\n* @callback OnClick\n* @param {Event} e\n* @param {string} targetAreaHref\n* @returns {void}\n*/\n\n/**\n * @callback MouseDown\n * @param {Event} e\n * @param {module:imageMaps.ShapeType} shapeType\n * @param {module:imageMaps.Coords} coords\n * @returns {void}\n */\n\n/**\n* @callback MouseMove\n* @param {Event} e\n* @param {module:imageMaps.ShapeType} shapeType\n* @param {module:imageMaps.MovedCoords} movedCoords\n* @returns {void}\n*/\n\n/**\n* @callback MouseUp\n* @param {Event} e\n* @param {module:imageMaps.ShapeType} shapeType\n* @param {module:imageMaps.ShapeCoords} updatedCoords\n* @returns {void}\n*/\n\n/**\n* @callback Select\n* @param {Event} e\n* @param {module:imageMaps.ShapeInfoOptions|\n*   module:imageMaps.ShapeSecondaryOptions} shapeInfo\n* @returns {void}\n*/\n\n/**\n* @typedef {PlainObject} module:imageMaps.ImageMapOptions\n* @property {boolean} [isEditMode=false]\n* @property {module:imageMaps.ShapeType} [shape=\"rect\"]\n* @property {string} [shapeText=\"press on link\"]\n* @property {module:imageMaps.ShapeStyles} [shapeStyle] Defaults to\n*   `{fill: '#ffffff', 'fill-opacity': 0.2,\n*     stroke: '#ffffff', 'stroke-width': 3}`\n* @property {OnClick} [onClick=function () {}]\n* @property {MouseDown} [onMouseDown=function () {}]\n* @property {MouseMove} [onMouseMove=function () {}]\n* @property {MouseUp} [onMouseUp=function () {}]\n* @property {Select} [onSelect=function () {}]\n*/\n\n/**\n * @type {module:imageMaps.ImageMapOptions}\n */\nconst defaults = {\n    isEditMode: false,\n    // select map area shape type - rect, circle, text, image, poly\n    shape: SHAPE.RECT,\n    shapeText: 'press on link', // shape 옵션이 text일 때 적용된다.\n    shapeStyle: {\n        fill: '#ffffff',\n        'fill-opacity': 0.2,\n        stroke: '#ffffff',\n        'stroke-width': 3\n    },\n    /* eslint-disable no-empty-function */\n    onClick (e, targetAreaHref) {},\n    onMouseDown (e, shapeType, coords) {},\n    onMouseMove (e, shapeType, movedCoords) {},\n    onMouseUp (e, shapeType, updatedCoords) {},\n    onSelect (e, shapeInfo) {}\n    /* eslint-enable no-empty-function */\n};\n\nconst defaultShapeOptions = {\n    // top-left-x, top-left-y, bottom-right-x, botton-right-y\n    rect: [0, 0, 20, 20],\n    circle: [0, 0, 10], // center-x, center-y, radius\n    ellipse: [0, 0, 5, 5], // center-x, center-y, radius-x, radius-y\n    text: [0, 0, 12] // bottom-right-x, bottom-right-y, font-size\n};\n\nconst FONT_SIZE_RATIO = 0.5;\n\nconst NS_SVG = 'http://www.w3.org/2000/svg';\nconst NS_XLINK = 'http://www.w3.org/1999/xlink';\n\n/**\n * Adds {@link external:\"jQuery.fn\"} methods.\n * @function module:imageMaps.jqueryImageMaps\n * @param {external:jQuery} $\n * @returns {external:jQuery}\n */\nfunction jqueryImageMaps ($) {\n    // The actual plugin constructor\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     */\n    class ImageMaps {\n        /**\n         *\n         * @param {external:jQuery} container\n         * @param {module:imageMaps.ImageMapOptions} [options]\n         */\n        constructor (container, options) {\n            this.container = $(container);\n            this.mapEl = null;\n            this.svgEl = null;\n            // merge the default options with user-provided options\n\n            this.options = $.extend(true, {}, defaults, options);\n            this.shapeType = this.options.shape;\n            this.isEditMode = this.options.isEditMode;\n            this.shapeStyle = this.options.shapeStyle;\n            this.shapeText = '';\n            this.shapeImageUrl = '';\n            this.shapeCoords = null;\n            this.vertexCoords = null;\n            this.grabType = null;\n\n            this.containerWidth = 0;\n            this.containerHeight = 0;\n\n            this.touchStartCoords = {\n                x: null, y: null\n            };\n            this.dragInfo = {\n                face: {x: null, y: null},\n                vertex: {x: null, y: null}\n            };\n\n            this.shapeLimitCoords = {\n                x: 30,\n                y: 30,\n                radius: 15\n            };\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         * ImageMaps: 이미지 엘리먼트 하단에 map, area 엘리먼트 생성 및 속성 부여.\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @returns {void}\n         */\n        createMaps (coords, linkUrl) {\n            const imageWidth = this.container.width();\n\n            if (Number.isNaN(imageWidth) || !imageWidth) {\n                this.container.one(\n                    'load',\n                    $.proxy(createMaps, this, coords, linkUrl)\n                );\n            } else {\n                createMaps.call(this, coords, linkUrl);\n            }\n        }\n\n        /**\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @returns {void}\n         */\n        setShapeType (shapeType) {\n            this.shapeType = shapeType;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setShapeStyle (styleOptions) {\n            styleOptions = styleOptions || {};\n            this.shapeStyle = $.extend({}, true, this.shapeStyle, styleOptions);\n        }\n\n        /**\n         * @todo Implement\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {void}\n         */\n        setUrl (linkUrl, index) { // eslint-disable-line class-methods-use-this\n            // Todo\n        }\n\n        /**\n         *\n         * @param {string} text\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setTextShape (text, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeText = text;\n        }\n\n        /**\n         *\n         * @param {string} imageUrl\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {void}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.setShapeStyle(styleOptions);\n            this.shapeImageUrl = imageUrl;\n        }\n\n        /**\n         *\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @param {module:imageMaps.ShapeType} [shapeType]\n         * @returns {void}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            if (shapeType) {\n                this.setShapeType(shapeType);\n            }\n            this.createMaps(coords, linkUrl);\n        }\n\n        /**\n         * @param {Integer} [index]\n         * @returns {void}\n         */\n        removeShape (index) {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            if (typeof index === 'undefined') {\n                index = this.shapeEl.data('index');\n            }\n\n            const areaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const shapeEl = this.svgEl.find(\n                '.' + shapeFaceClass + '[data-index=\"' + index + '\"]'\n            );\n\n            this.detachEvents(shapeEl, [{\n                type: 'click touchend'\n            }]);\n\n            shapeEl.parent().remove();\n            areaEl.remove();\n\n            this.removeShapeInfo(index);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        removeAllShapes () {\n            if (!this.shapeEl) {\n                return;\n            }\n\n            const allShapeEls = this.svgEl.find('.' + shapeFaceClass);\n\n            allShapeEls.each((i, shapeEl) => {\n                this.removeShape($(shapeEl).data('index'));\n            });\n\n            this.allShapeInfo = {};\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        removeImageMaps () {\n            this.removeAllShapes();\n            this.svgEl && this.svgEl.remove();\n        }\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.ShapeInfoOptions\n        * @property {Integer} index\n        * @property {module:imageMaps.ShapeCoords} coords\n        * @property {module:imageMaps.ShapeType} type\n        * @property {Url} url\n        * @property {module:imageMaps.ShapeStyles} style\n        */\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.ShapeSecondaryOptions\n        * @property {string} text\n        * @property {HTMLImageElement|string} href\n        */\n\n        /**\n         *\n         * @param {Integer} index\n         * @param {module:imageMaps.ShapeInfoOptions} shapeOptions\n         * @param {\n         *   module:imageMaps.ShapeSecondaryOptions\n         * } [shapeSecondaryOptions]\n         * @returns {void}\n         */\n        updateShapeInfo (index, shapeOptions, shapeSecondaryOptions) {\n            const shapeInfo = this.allShapeInfo;\n\n            shapeOptions.index = index;\n            if (!shapeInfo['shape' + index]) {\n                shapeInfo['shape' + index] = $.extend(\n                    true, shapeOptions, shapeSecondaryOptions\n                );\n            } else {\n                shapeInfo['shape' + index] = $.extend(\n                    true,\n                    {},\n                    shapeInfo['shape' + index],\n                    shapeOptions,\n                    shapeSecondaryOptions\n                );\n            }\n        }\n\n        /**\n         * @param {Integer} index\n         * @returns {void}\n         */\n        removeShapeInfo (index) {\n            delete this.allShapeInfo['shape' + index];\n        }\n\n        /**\n         *\n         * @param {Integer} index\n         * @returns {module:imageMaps.ShapeInfoOptions|\n         *   module:imageMaps.ShapeSecondaryOptions}\n         */\n        getShapeInfo (index) {\n            return this.allShapeInfo['shape' + index];\n        }\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.AllShapeInfo\n        * @property {module:imageMaps.ShapeType} type\n        * @property {module:imageMaps.Coords} coords\n        * @property {Integer} index\n        * @property {module:imageMaps.ShapeInfoOptions|\n        *   module:imageMaps.ShapeSecondaryOptions} shape<num>\n        */\n        /**\n         *\n         * @returns {module:imageMaps.AllShapeInfo}\n         */\n        getAllShapesInfo () {\n            return $.extend(true, {}, this.allShapeInfo);\n        }\n\n        /**\n         *\n         * @param {Float[]} percentages\n         * @returns {void}\n         */\n        zoom (percentages) {\n            zoom.call(this, percentages);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        enableClick () {\n            this.attachEvents(this.svgEl.find('.' + shapeFaceClass), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @returns {void}\n         */\n        disableClick () {\n            this.detachEvents(this.svgEl.find('.' + shapeFaceClass), [{\n                type: 'touchstart', handler: onTouchStart\n            }, {\n                type: 'click touchend', handler: onClickShapeFace\n            }]);\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeCoords} coords\n         * @returns {void}\n         */\n        setShapeCoords (coords) {\n            this.shapeCoords = coords;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.VertexCoords} coords\n         * @returns {void}\n         */\n        setVertexCoords (coords) {\n            this.vertexCoords = coords;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.ShapeElement} element\n         * @returns {void}\n         */\n        setShapeElement (element) {\n            this.shapeEl = element;\n        }\n\n        /**\n        * @typedef {Element} module:imageMaps.VertexElement\n        */\n        /**\n         *\n         * @param {module:imageMaps.VertexElement} element\n         * @returns {void}\n         */\n        setVertexElement (element) {\n            this.vertexEl = element;\n        }\n\n        /**\n         *\n         * @param {module:imageMaps.VertexElements} elements\n         * @returns {void}\n         */\n        setVertexElements (elements) {\n            this.vertexEls = elements;\n        }\n\n        /**\n        * @callback Handler\n        * @param {Event} e\n        * @param {...any} extraParameters\n        * @returns {boolean}\n        */\n\n        /**\n        * @typedef {PlainObject} module:imageMaps.TypeHandler\n        * @property {string} type\n        * @property {Handler} handler\n        */\n\n        /**\n         * ImageMaps: 이미지맵 이벤트 할당.\n         * @param {Node|external:jQuery} element\n         * @param {module:imageMaps.TypeHandler[]} eventOptions\n         * @returns {void}\n         */\n        attachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                element.on(\n                    type + '.' + areaClass,\n                    $.proxy(handler, this)\n                );\n            });\n        }\n\n        /**\n         * ImageMaps: 이미지맵 이벤트 해제.\n         * @param {external:jQuery} element\n         * @param {module:imageMaps.TypeHandler[]} eventOptions\n         * @returns {void}\n         */\n        detachEvents (element, eventOptions) {\n            element = $(element);\n\n            eventOptions.forEach(({type, handler}) => {\n                const eventType = type || '';\n                const eventHandler = handler\n                    ? $.proxy(handler, this)\n                    : '';\n\n                if (eventHandler) {\n                    element.off(eventType + '.' + areaClass, eventHandler);\n                } else {\n                    element.off(eventType + '.' + areaClass);\n                }\n            });\n        }\n    }\n    ImageMaps.getCoordsByRatio = getCoordsByRatio;\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {?(module:imageMaps.Coords)} coords\n     * @param {Url} linkUrl\n     * @returns {void}\n     */\n    function createMaps (coords, linkUrl) {\n        // 최초 맵영역을 만드는 순간에 map 엘리먼트를 만들고 하위에 area 엘리먼트 생성.\n        const uid = guid();\n        if (!this.container.attr('usemap')) {\n            this.mapEl = $(\n                '<map name=' + uid + '></map>'\n            ).insertAfter(this.container);\n            this.container.attr('usemap', '#' + uid);\n        } else {\n            const usemapName = this.container.attr('usemap').replace('#', '');\n            this.mapEl = $('body').find('map[name=' + usemapName + ']');\n        }\n\n        this.containerWidth = this.container.width();\n        this.containerHeight = this.container.height();\n\n        const imageWidth = this.containerWidth;\n        const imageHeight = this.containerHeight;\n        const centerX = imageWidth / 2;\n        const centerY = imageHeight / 2;\n\n        // 파라미터로 좌표값을 받으면 좌표에 해당하는 영역을 함께 그려준다.\n        const {shapeType} = this;\n\n        let shapeCoords = [];\n        let isDefaultTextCoords = false;\n\n        coords = convertStringToNumber(coords);\n        if (!(Array.isArray(coords))) {\n            // default 편집영역의 사이즈는 이미지의 0.1배로 계산. (내 맘대로..)\n            let defaultShapeX = imageWidth * 0.1,\n                defaultShapeY = imageHeight * 0.1;\n            const defaultRadius = (defaultShapeX >= defaultShapeY)\n                ? defaultShapeY\n                : defaultShapeX;\n            // invalid 좌표값이거나 배열이 아닌 타입일 경우는 디폴트 좌표로 그린다.\n            if (shapeType === SHAPE.RECT) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ]);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, [\n                    centerX,\n                    centerY,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, [\n                    centerX,\n                    centerY,\n                    defaultRadius,\n                    defaultRadius\n                ]);\n            } else if (shapeType === SHAPE.IMAGE) {\n                const imageSize = getNaturalImageSize(this.shapeImageUrl);\n                defaultShapeX = imageSize.width / 2;\n                defaultShapeY = imageSize.height / 2;\n                shapeCoords = [\n                    centerX - defaultShapeX,\n                    centerY - defaultShapeY,\n                    centerX + defaultShapeX,\n                    centerY + defaultShapeY\n                ];\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        } else {\n            // 타입별로 정상적으로 좌표값을 받았다면 해당 좌표로 그린다.\n            // eslint-disable-next-line no-lonely-if\n            if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n                shapeCoords = $.extend([], defaultShapeOptions.rect, coords);\n            } else if (shapeType === SHAPE.CIRCLE) {\n                shapeCoords = $.extend([], defaultShapeOptions.circle, coords);\n            } else if (shapeType === SHAPE.ELLIPSE) {\n                shapeCoords = $.extend([], defaultShapeOptions.ellipse, coords);\n            } else if (shapeType === SHAPE.TEXT) {\n                if (!coords[0]) {\n                    coords[0] = centerX;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[1]) {\n                    coords[1] = centerY;\n                    isDefaultTextCoords = true;\n                }\n                if (!coords[2]) {\n                    coords[2] = 20;\n                }\n                shapeCoords = $.extend([], defaultShapeOptions.text, coords);\n            } else if (shapeType === SHAPE.POLY) {\n                // Todo\n            }\n        }\n\n        const index = this.mapEl.find('.' + shapeFaceClass).length;\n        let areaType = shapeType;\n        let shapeSecondaryOptions = {};\n\n        if (shapeType === SHAPE.TEXT || shapeType === SHAPE.IMAGE) {\n            areaType = SHAPE.RECT;\n\n            shapeSecondaryOptions = shapeType === SHAPE.TEXT\n                ? {text: this.shapeText}\n                : {href: this.shapeImageUrl};\n        }\n\n        createOverlay.call(this, shapeCoords, uid, linkUrl, index);\n        this.setShapeCoords(shapeCoords);\n        this.updateShapeInfo(index, {\n            coords: shapeCoords,\n            type: shapeType,\n            url: linkUrl,\n            style: this.shapeStyle\n        }, shapeSecondaryOptions);\n\n        if (isDefaultTextCoords && this.isEditMode &&\n            shapeType === SHAPE.TEXT\n        ) {\n            adjustTextShape.call(this);\n        }\n\n        if (shapeType === SHAPE.ELLIPSE) {\n            areaType = SHAPE.CIRCLE;\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n\n        createArea.call(this, areaType, shapeCoords, linkUrl, index);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {string} uid\n     * @param {Url} linkUrl\n     * @param {Integer} index\n     * @returns {void}\n     */\n    function createOverlay (shapeCoords, uid, linkUrl, index) {\n        const containerWidth = this.container.width(),\n            containerHeight = this.container.height();\n\n        if (typeof document.createElementNS !== 'undefined') {\n            let svgNativeEl = this.mapEl.find('svg').get(0);\n            let svgEl = $(svgNativeEl);\n            const {shapeType} = this;\n\n            if (!svgNativeEl) {\n                svgNativeEl = document.createElementNS(NS_SVG, 'svg');\n                svgEl = $(svgNativeEl);\n                this.svgEl = svgEl;\n\n                if (this.isEditMode) {\n                    this.attachEvents(svgEl, [{\n                        type: 'mousedown', handler: onMouseDown\n                    }]);\n                } else {\n                    this.attachEvents(this.mapEl, [{\n                        type: 'touchstart', handler: onTouchStart\n                    }, {\n                        type: 'click touchend', handler: onClickShapeFace\n                    }]);\n                }\n                this.attachEvents(window, [{\n                    type: 'resize', handler: onResize\n                }]);\n            }\n\n            // svgEl.get(0).setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n            // svg의 width, height는 DOM API로 처리해야 사이즈가 제대로 나옴.\n            svgNativeEl.setAttribute('width', containerWidth);\n            svgNativeEl.setAttribute('height', containerHeight);\n\n            // container의 부모에 대한 상대좌표에 따라 svg의 좌표값이 결정된다.\n            const containerPos = this.container.position();\n            svgEl.attr({\n                xmlns: NS_SVG,\n                'xmlns:xlink': NS_XLINK,\n                version: '1.1',\n                'data-Id': uid\n            }).css({\n                position: 'absolute',\n                zIndex: 1000,\n                overflow: 'hidden',\n                top: containerPos.top,\n                left: containerPos.left\n            });\n\n            const shapeGroupEl = createShape.call(\n                this,\n                shapeType,\n                shapeCoords,\n                linkUrl,\n                index\n            );\n            svgEl.append(shapeGroupEl);\n            this.mapEl.append(svgEl);\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {string} areaType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {void}\n     */\n    function createArea (areaType, shapeCoords, linkUrl, index) {\n        $(\n            '<area shape=' + areaType +\n                ' coords=' + shapeCoords.join(',') +\n                ' href=' + (linkUrl || '#') +\n                ' data-index=' + index + ' ' +\n                (linkUrl ? 'target=\"_blank\"' : '') +\n                '>'\n        ).appendTo(this.mapEl);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Url} linkUrl\n     * @param {string|Integer} index\n     * @returns {void}\n     */\n    function createShape (shapeType, shapeCoords, linkUrl, index) {\n        if (shapeType === SHAPE.POLY) {\n            shapeType = SHAPE.POLYLINE;\n        }\n\n        const shapeEl = $(document.createElementNS(NS_SVG, shapeType));\n        const gEl = $(document.createElementNS(NS_SVG, 'g'));\n\n        drawShape.call(this, shapeCoords, shapeEl);\n\n        let cursor = 'default';\n        if (this.isEditMode) {\n            cursor = 'move';\n        } else if (linkUrl !== '') {\n            cursor = 'pointer';\n        }\n        this.setShapeStyle({cursor});\n        shapeEl.css(this.shapeStyle);\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeEl.css({\n                'fill-opacity': '',\n                'stroke-opacity': ''\n            });\n        }\n\n        shapeEl.attr('data-index', index);\n        gEl.append(shapeEl);\n        this.setShapeElement(shapeEl);\n\n        if (this.isEditMode && shapeType !== 'text') {\n            const vertexEls = createVertex(shapeType, shapeCoords, index);\n            gEl.append(...vertexEls);\n            this.setVertexElements(vertexEls);\n        }\n\n        return gEl;\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.ShapeOptions\n    * @property {string} text\n    * @property {string} href\n    * @property {module:imageMaps.ShapeType} type\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {module:imageMaps.ShapeElement} [shapeEl]\n     * @param {module:imageMaps.ShapeOptions} [shapeOptions]\n     * @returns {void}\n     */\n    function drawShape (shapeCoords, shapeEl, shapeOptions) {\n        shapeEl = shapeEl || this.shapeEl;\n        const shapeType = shapeOptions ? shapeOptions.type : this.shapeType;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('width', shapeCoords[2] - shapeCoords[0]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('height', shapeCoords[3] - shapeCoords[1]);\n            }\n            if (shapeType === SHAPE.IMAGE) {\n                // xlink 속성 설정 시에는 DOM api의 setAttributeNS를 사용해야 함.\n                // svg 전용 속성은 무조건 DOM api를 사용해야 함.\n                shapeEl.get(0).setAttributeNS(\n                    NS_XLINK,\n                    'href',\n                    (shapeOptions ? shapeOptions.href : this.shapeImageUrl)\n                );\n                // image 엘리먼트의 width, height를 고정 비율로 변경되는 걸 해제해주기 위한 속성 셋팅.\n                shapeEl.get(0).setAttribute('preserveAspectRatio', 'none');\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('r', shapeCoords[2]);\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeEl.attr({\n                cx: shapeCoords[0],\n                cy: shapeCoords[1],\n                class: shapeFaceClass\n            });\n            if (shapeCoords[2]) {\n                shapeEl.attr('rx', shapeCoords[2]);\n            }\n            if (shapeCoords[3]) {\n                shapeEl.attr('ry', shapeCoords[3]);\n            }\n        } else if (shapeType === SHAPE.TEXT) {\n            shapeEl.attr({\n                x: shapeCoords[0],\n                y: shapeCoords[1],\n                'font-size': shapeCoords[2],\n                class: shapeFaceClass\n            });\n            shapeEl.text((shapeOptions && shapeOptions.text) || this.shapeText);\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @returns {void}\n     */\n    function adjustTextShape () {\n        const {shapeEl} = this;\n        const shapeSize = shapeEl.get(0).getBBox();\n        const centerX = shapeSize.width / 2;\n        const centerY = Number.parseFloat(\n            shapeEl.attr('font-size')\n        ) * FONT_SIZE_RATIO / 2;\n        const bottomRightX = Number.parseInt(shapeEl.attr('x'));\n        const bottomRightY = Number.parseInt(shapeEl.attr('y'));\n        const resultX = bottomRightX - centerX;\n        const resultY = bottomRightY + centerY;\n\n        this.updateShapeInfo(shapeEl.data('index'), {\n            coords: [resultX, resultY, shapeEl.attr('font-size')]\n        });\n\n        shapeEl.attr({\n            x: resultX,\n            y: resultY\n        });\n    }\n\n    /**\n     * `SVGRect` element for each vertex coordinate.\n     * @typedef {SVGRect[]} module:imageMaps.VertexElements One\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Integer} index\n     * @returns {module:imageMaps.VertexElements}\n     */\n    function createVertex (shapeType, shapeCoords, index) {\n        const vertexCoords = calculateVertexCoords(shapeType, shapeCoords);\n\n        const vertexTemp = vertexCoords.map(() => {\n            const vertexEl = $(document.createElementNS(NS_SVG, 'rect'));\n            vertexEl.attr('data-index', index).css({\n                fill: '#ffffff',\n                stroke: '#000000',\n                'stroke-width': 2\n            });\n            return vertexEl;\n        });\n\n        drawVertex(vertexCoords, vertexTemp, shapeType);\n\n        return vertexTemp;\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.VertexCoords\n    * @property {Float} x\n    * @property {Float} y\n    * @property {module:imageMaps.CursorType} type\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.VertexCoords} vertexCoords\n     * @param {module:imageMaps.VertexElements} vertexEls\n     * @param {module:imageMaps.ShapeType} shapeType Not currently in use\n     * @returns {void}\n     */\n    function drawVertex (vertexCoords, vertexEls, shapeType) {\n        vertexCoords.forEach((eachCoords, i) => {\n            $(vertexEls[i]).attr({\n                x: eachCoords.x - 3,\n                y: eachCoords.y - 3,\n                width: 7,\n                height: 7,\n                'data-direction': eachCoords.type,\n                class: shapeVertexClass\n            }).css('cursor', getCursor(eachCoords.type));\n        });\n    }\n\n    /**\n    * @typedef {module:imageMaps.Coords} module:imageMaps.ShapeCoords\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @returns {module:imageMaps.VertexCoords}\n     */\n    function calculateVertexCoords (shapeType, shapeCoords) {\n        let vertexArr = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            // 좌상, 좌하, 우상, 우하, 상, 하, 좌, 우 순\n            // 개별 vertex의 좌표값이므로 좌표의 순서는 크게 상관 없지만 참고로...\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1], type: 'nw'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[3], type: 'sw'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[1], type: 'ne'\n            }, {\n                x: shapeCoords[2], y: shapeCoords[3], type: 'se'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[1], type: 'n'\n            }, {\n                x: (shapeCoords[2] - shapeCoords[0]) / 2 + shapeCoords[0],\n                y: shapeCoords[3],\n                type: 's'\n            }, {\n                x: shapeCoords[0],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'w'\n            }, {\n                x: shapeCoords[2],\n                y: (shapeCoords[3] - shapeCoords[1]) / 2 + shapeCoords[1],\n                type: 'e'\n            }];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[2], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[2], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            // 상, 하, 좌, 우\n            vertexArr = [{\n                x: shapeCoords[0], y: shapeCoords[1] - shapeCoords[3], type: 'n'\n            }, {\n                x: shapeCoords[0], y: shapeCoords[1] + shapeCoords[3], type: 's'\n            }, {\n                x: shapeCoords[0] - shapeCoords[2], y: shapeCoords[1], type: 'w'\n            }, {\n                x: shapeCoords[0] + shapeCoords[2], y: shapeCoords[1], type: 'e'\n            }];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return vertexArr;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeCoords} shapeCoords\n     * @param {Element} areaEl\n     * @param {module:imageMaps.ShapeType} [shapeType]\n     * @returns {void}\n     */\n    function drawArea (shapeCoords, areaEl, shapeType) {\n        const shapeEl = this.svgEl.find(\n            '.' + shapeFaceClass + '[data-index=\"' + areaEl.data('index') + '\"]'\n        );\n        shapeType = shapeType || this.shapeType;\n\n        if (shapeType === SHAPE.TEXT) {\n            shapeCoords = convertTextToRectCoords(shapeEl);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            shapeCoords = [\n                shapeCoords[0],\n                shapeCoords[1],\n                defaultShapeOptions.ellipse[2]\n            ];\n        }\n        areaEl.attr('coords', shapeCoords.join(','));\n    }\n\n    /**\n    * @typedef {\"col\"|\"row\"|Direction|\"ew\"|\n    * \"ns\"|\"nesw\"|\"nwse\"} module:imageMaps.CursorType\n    */\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.CursorType} type\n     *     CSS cursor resize type\n     * @returns {string}\n     */\n    function getCursor (type) {\n        return type + '-resize';\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `touchstart` event\n     * @returns {void}\n     */\n    function onTouchStart (e) {\n        const touchCoords = e.originalEvent.touches[0];\n        this.touchStartCoords.x = touchCoords.pageX;\n        this.touchStartCoords.y = touchCoords.pageY;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `click touchend` event\n     * @returns {void}\n     */\n    function onClickShapeFace (e) {\n        // IE8이 이외의 브라우저는 아래 계산 로직을 타지 않아도 된다.\n        // IE8은 area 엘리먼트 클릭 시 href 속성의 url로 이동.\n        let targetAreaEl = $(e.currentTarget);\n        if (e.currentTarget.tagName.toLowerCase() !== 'area') {\n            e.preventDefault();\n            if ((this.dragInfo.face.x && this.dragInfo.face.x !== e.pageX) ||\n                (this.dragInfo.face.y && this.dragInfo.face.y !== e.pageY) ||\n                e.target.tagName.toLowerCase() === 'svg' ||\n                (e.type === 'touchend' &&\n                    e.originalEvent.changedTouches[0].pageX !==\n                      this.touchStartCoords.x &&\n                    e.originalEvent.changedTouches[0].pageY !==\n                      this.touchStartCoords.y)\n            ) {\n                return;\n            }\n\n            // 클릭하거나 마우스엔터, 마우스다운 된 shape를 현재 타겟으로 저장.\n            // 타겟이 되는 shape의 좌표 정보를 가지고 모든 로직이 수행되도록 한다.\n            const targetEl = $(e.target);\n            const index = targetEl.attr('data-index');\n            targetAreaEl = this.mapEl.find('area[data-index=\"' + index + '\"]');\n            const url = targetAreaEl.attr('href');\n\n            (url !== '#') && window.open(targetAreaEl.attr('href'));\n        }\n\n        this.options.onClick.call(this, e, targetAreaEl.attr('href'));\n    }\n\n    // drag & drop\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mousedown` event\n     * @returns {void}\n     */\n    function onMouseDown (e) {\n        e.preventDefault();\n\n        if (e.target.tagName.toLowerCase() === 'svg') {\n            return;\n        }\n\n        const targetEl = $(e.target);\n        const index = targetEl.attr('data-index');\n        const shapeInfo = this.getShapeInfo(index);\n        const groupEl = targetEl.parent();\n        const shapeEl = groupEl.find(':first-child');\n        let coords = [];\n        let shapeType = shapeEl.get(0).tagName.toLowerCase();\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const targetX = Number.parseInt(shapeEl.attr('x'));\n            const targetY = Number.parseInt(shapeEl.attr('y'));\n            coords = [\n                targetX,\n                targetY,\n                targetX + Number.parseInt(shapeEl.attr('width')),\n                targetY + Number.parseInt(shapeEl.attr('height'))\n            ];\n            if (shapeType === SHAPE.IMAGE) {\n                this.setImageShape(shapeEl.attr('href'));\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            const targetX = Number.parseInt(shapeEl.attr('cx'));\n            const targetY = Number.parseInt(shapeEl.attr('cy'));\n            coords = [targetX, targetY, Number.parseInt(shapeEl.attr('r'))];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            const targetX = Number.parseInt(shapeEl.attr('cx'));\n            const targetY = Number.parseInt(shapeEl.attr('cy'));\n            coords = [\n                targetX, targetY,\n                Number.parseInt(shapeEl.attr('rx')),\n                Number.parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            const targetX = Number.parseFloat(shapeEl.attr('x'));\n            const targetY = Number.parseFloat(shapeEl.attr('y'));\n            const fontSize = Number.parseFloat(shapeEl.attr('font-size'));\n            coords = [targetX, targetY, fontSize];\n            this.shapeText = shapeEl.text();\n        } else if (shapeType === SHAPE.POLYGON) {\n            shapeType = SHAPE.POLY;\n        }\n\n        this.setShapeType(shapeType);\n        this.setShapeElement(shapeEl);\n        this.setShapeCoords(coords);\n\n        if (shapeType !== SHAPE.TEXT) {\n            shapeEl.attr('data-fill', shapeEl.css('fill'));\n            shapeEl.css('fill', '#ffffff');\n\n            this.setVertexCoords(calculateVertexCoords(shapeType, coords));\n\n            const vertexTemp = [];\n            const vertexEls = this.mapEl.find(\n                '.' + shapeVertexClass + '[data-index=\"' + index + '\"]'\n            );\n            vertexEls.each(function () {\n                vertexTemp.push($(this));\n            });\n            this.setVertexElements(vertexTemp);\n        }\n\n        if (targetEl.is('.' + shapeFaceClass)) {\n            this.grabType = 'face';\n            declareShape.call(this, targetEl, e.pageX, e.pageY);\n        } else if (targetEl.is('.' + shapeVertexClass)) {\n            this.grabType = 'vertex';\n            declareVertex.call(this, targetEl, index);\n        }\n\n        this.attachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onSelect.call(this, e, shapeInfo);\n        this.options.onMouseDown.call(this, e, shapeType, coords);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mouseup` event\n     * @returns {void}\n     */\n    function onMouseUp (e) {\n        const targetEl = $(e.target);\n        const {shapeEl} = this;\n\n        shapeEl.css('fill', shapeEl.attr('data-fill'));\n        targetEl.attr('data-movable', false);\n\n        const updatedCoords = determineShape.call(this);\n        this.setShapeCoords(updatedCoords);\n        this.updateShapeInfo(shapeEl.data('index'), {coords: updatedCoords});\n\n        this.detachEvents(this.mapEl.parent(), [{\n            type: 'mouseup', handler: onMouseUp\n        }, {\n            type: 'mousemove', handler: onMouseMove\n        }]);\n\n        this.options.onMouseUp.call(this, e, this.shapeType, updatedCoords);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `mousemove` event\n     * @returns {void}\n     */\n    function onMouseMove (e) {\n        const targetEl = $(e.target);\n        const [x, y] = this.shapeCoords;\n        const {grabType, shapeType} = this;\n        let coords = {};\n\n        // 좌표 계산 시 e.offsetX, offsetY값은 이벤트 발생 대상(e.currentTarget)\n        //   기준 좌표 값이므로\n        // 이벤트 발생 도중(특히 mousemove) 겹치는 이벤트 타겟이 생기면 해당 타겟 기준\n        //    좌표로 변경되어 좌표가 튀는 현상 발생.\n        // 그러므로 브라우저에서 drag & drop 구현 시 웬만하면 브라우저의 절대 좌표값인\n        //    e.pageX, pageY를 사용하도록 한다.\n        if (grabType === 'face' || grabType === 'vertex') {\n            if (grabType === 'face') {\n                const movedX = x + e.pageX;\n                const movedY = y + e.pageY;\n\n                coords = getMovedShapeCoords.call(\n                    this,\n                    movedX - this.dragInfo.face.x,\n                    movedY - this.dragInfo.face.y\n                );\n            } else if (grabType === 'vertex') {\n                coords = getMovedVertexCoords.call(\n                    this,\n                    e.pageX - this.svgEl.offset().left,\n                    e.pageY - this.svgEl.offset().top\n                );\n            }\n            if (!coords) {\n                return;\n            }\n\n            if (shapeType !== SHAPE.TEXT) {\n                this.setVertexCoords(coords.vertexCoords);\n                drawVertex(coords.vertexCoords, this.vertexEls, this.shapeType);\n            }\n            const index = Number.parseInt(coords.grabEl.attr('data-index'));\n            drawShape.call(\n                this,\n                coords.movedCoords,\n                this.svgEl.find(\n                    '.' + shapeFaceClass + '[data-index=\"' + index + '\"]'\n                )\n            );\n            drawArea.call(\n                this,\n                coords.movedCoords,\n                this.mapEl.find('area[data-index=\"' + index + '\"]')\n            );\n\n            // svg 내 엘리먼트들은 z-index 영향을 받지 않고 document 순서에 영향을 받는다.\n            // 그래서 drag 시 다른 요소들보다 최상위에 두려면 엘리먼트 순서를 부모의 가장 하위에 두어야 한다.\n            // mousedown에서 이 로직을 넣을 경우,\n            // 외부에서 click 이벤트를 할당했을 때 mousedown 핸들러에서 dom 우선순위 조정하는 과정에서\n            //    click 이벤트가 해제되는 이슈로 mousemove 안에 둠.\n            if (\n                (\n                    targetEl.is('.' + shapeFaceClass) ||\n                    targetEl.is('.' + shapeVertexClass)\n                ) &&\n                (Math.abs(this.dragInfo.face.x - e.pageX) <= 1 ||\n                    Math.abs(this.dragInfo.face.y - e.pageY) <= 1)\n            ) {\n                this.svgEl.append(targetEl.parent());\n            }\n\n            this.options.onMouseMove.call(\n                this,\n                e,\n                shapeType,\n                coords.movedCoords\n            );\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Event} e The `resize` event\n     * @returns {void}\n     */\n    function onResize (e) {\n        const containerWidth = this.container.width();\n        const containerHeight = this.container.height();\n\n        if (this.containerWidth !== containerWidth ||\n            this.containerHeight !== containerHeight\n        ) {\n            redraw.call(this, containerWidth, containerHeight);\n        }\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float[]} percentages\n     * @returns {void}\n     */\n    function zoom (percentages) {\n        const widthPercentage = percentages[0];\n        const heightPercentage = (percentages.length < 2)\n            ? widthPercentage\n            : percentages[1];\n        const containerWidth = widthPercentage * 0.01 * this.container.width();\n        const containerHeight = heightPercentage * 0.01 *\n            this.container.height();\n\n        this.container.css({\n            width: containerWidth + 'px',\n            height: containerHeight + 'px'\n        });\n\n        setTimeout(() => {\n            if (this.svgEl && this.svgEl.length > 0) {\n                redraw.call(this, containerWidth, containerHeight);\n            }\n        });\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} containerWidth\n     * @param {Float} containerHeight\n     * @returns {void}\n     */\n    function redraw (containerWidth, containerHeight) {\n        const {allShapeInfo} = this;\n        const widthRatio = containerWidth / this.containerWidth;\n        const heightRatio = containerHeight / this.containerHeight;\n        const containerPos = this.container.position();\n\n        this.svgEl.get(0).setAttribute('width', containerWidth);\n        this.svgEl.get(0).setAttribute('height', containerHeight);\n        this.svgEl.css({\n            top: containerPos.top,\n            left: containerPos.left\n        });\n\n        $.each(allShapeInfo, (index, item) => {\n            item.coords = getCoordsByRatio(\n                item.coords, item.type, widthRatio, heightRatio\n            );\n\n            drawVertex(\n                calculateVertexCoords(item.type, item.coords),\n                this.svgEl.find(\n                    '.' + shapeVertexClass + '[data-index=\"' + item.index + '\"]'\n                ),\n                item.type\n            );\n            drawShape.call(\n                this,\n                item.coords,\n                this.svgEl.find(\n                    '.' + shapeFaceClass + '[data-index=\"' + item.index + '\"]'\n                ),\n                item\n            );\n            drawArea.call(\n                this,\n                item.coords,\n                this.mapEl.find('area[data-index=\"' + item.index + '\"]'),\n                item.type\n            );\n        });\n\n        this.containerWidth = containerWidth;\n        this.containerHeight = containerHeight;\n    }\n\n    /**\n    * @typedef {Element} module:imageMaps.ShapeElement\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.ShapeElement} shapeEl\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {void}\n     */\n    function declareShape (shapeEl, x, y) {\n        this.dragInfo.face.x = x;\n        this.dragInfo.face.y = y;\n\n        shapeEl.attr('data-movable', true);\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.MovedCoords\n    * @property {module:imageMaps.Coords} movedCoords\n    * @property {module:imageMaps.VertexCoords} vertexCoords\n    * @property {module:imageMaps.ShapeElement} grabEl\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {module:imageMaps.MovedCoords|void}\n     */\n    function getMovedShapeCoords (x, y) {\n        const {shapeEl} = this;\n        if (shapeEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n        const {shapeType} = this;\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const width = Number.parseInt(shapeEl.attr('width'));\n            const height = Number.parseInt(shapeEl.attr('height'));\n            const movedBottomRightX = x + width;\n            const movedBottomRightY = y + height;\n\n            movedCoords = [x, y, movedBottomRightX, movedBottomRightY];\n            vertexCoords = calculateVertexCoords(SHAPE.RECT, movedCoords);\n        } else if (shapeType === SHAPE.CIRCLE) {\n            movedCoords = [x, y, Number.parseInt(shapeEl.attr('r'))];\n            vertexCoords = calculateVertexCoords(SHAPE.CIRCLE, movedCoords);\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            movedCoords = [\n                x,\n                y,\n                Number.parseInt(shapeEl.attr('rx')),\n                Number.parseInt(shapeEl.attr('ry'))\n            ];\n            vertexCoords = calculateVertexCoords(SHAPE.ELLIPSE, movedCoords);\n        } else if (shapeType === SHAPE.TEXT) {\n            movedCoords = [x, y];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: shapeEl\n        };\n    }\n\n    /**\n    * @typedef {GenericArray} module:imageMaps.Coords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @returns {module:imageMaps.Coords}\n     */\n    function determineShape () {\n        const {shapeEl, shapeType} = this;\n        let updatedCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            const x = Number.parseInt(shapeEl.attr('x'));\n            const y = Number.parseInt(shapeEl.attr('y'));\n            updatedCoords = [\n                x,\n                y,\n                x + Number.parseInt(shapeEl.attr('width')),\n                y + Number.parseInt(shapeEl.attr('height'))\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            updatedCoords = [\n                Number.parseInt(shapeEl.attr('cx')),\n                Number.parseInt(shapeEl.attr('cy')),\n                Number.parseInt(shapeEl.attr('r'))\n            ];\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            updatedCoords = [\n                Number.parseInt(shapeEl.attr('cx')),\n                Number.parseInt(shapeEl.attr('cy')),\n                Number.parseInt(shapeEl.attr('rx')),\n                Number.parseInt(shapeEl.attr('ry'))\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            updatedCoords = [\n                Number.parseInt(shapeEl.attr('x')),\n                Number.parseInt(shapeEl.attr('y'))\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return updatedCoords;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {external:jQuery} vertexEl\n     * @param {Integer} index Not currently in use\n     * @returns {void}\n     */\n    function declareVertex (vertexEl, index) {\n        this.setVertexElement(vertexEl);\n\n        let vertexIndex = 0;\n        this.vertexEls.forEach((item, idx) => {\n            if (vertexEl.get(0) === item.get(0)) {\n                vertexIndex = idx;\n            }\n        });\n\n        const coords = this.vertexCoords[vertexIndex];\n        this.dragInfo.vertex.x = coords.x;\n        this.dragInfo.vertex.y = coords.y;\n\n        vertexEl.attr('data-movable', true);\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} x\n     * @param {Float} y\n     * @returns {module:imageMaps.MovedVertexCoords|void}\n     */\n    function getMovedVertexCoords (x, y) {\n        if (this.vertexEl.attr('data-movable') === 'false') {\n            return undefined;\n        }\n\n        let movedCoords = [];\n        let vertexCoords = [];\n\n        const {shapeType} = this;\n        const direction = this.vertexEl.attr('data-direction');\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE) {\n            switch (direction) {\n            // 좌상\n            case 'nw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, y, this.shapeCoords[2], this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 좌하\n            case 'sw':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [x, this.shapeCoords[1], this.shapeCoords[2], y],\n                    direction\n                );\n                break;\n            // 우상\n            case 'ne':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], y, x, this.shapeCoords[3]],\n                    direction\n                );\n                break;\n            // 우하\n            case 'se':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [this.shapeCoords[0], this.shapeCoords[1], x, y],\n                    direction\n                );\n                break;\n            // 상\n            case 'n':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        y,\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 하\n            case 's':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        y\n                    ],\n                    direction\n                );\n                break;\n            // 좌\n            case 'w':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        x,\n                        this.shapeCoords[1],\n                        this.shapeCoords[2],\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            // 우\n            case 'e':\n                movedCoords = getValidCoordsForRect.call(\n                    this,\n                    [\n                        this.shapeCoords[0],\n                        this.shapeCoords[1],\n                        x,\n                        this.shapeCoords[3]\n                    ],\n                    direction\n                );\n                break;\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            }\n        } else if (shapeType === SHAPE.CIRCLE) {\n            switch (direction) {\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(\n                        this,\n                        this.shapeCoords[1] - y\n                    )\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x)\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0])\n                ];\n                break;\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            }\n        } else if (shapeType === SHAPE.ELLIPSE) {\n            switch (direction) {\n            case 'n':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[1] - y)\n                ];\n                break;\n            case 's':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    this.shapeCoords[2],\n                    getValidCoordsForCircle.call(this, y - this.shapeCoords[1])\n                ];\n                break;\n            case 'w':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, this.shapeCoords[0] - x),\n                    this.shapeCoords[3]\n                ];\n                break;\n            case 'e':\n                movedCoords = [\n                    this.shapeCoords[0],\n                    this.shapeCoords[1],\n                    getValidCoordsForCircle.call(this, x - this.shapeCoords[0]),\n                    this.shapeCoords[3]\n                ];\n                break;\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unexpected direction', direction);\n                break;\n            }\n        } else if (shapeType === SHAPE.POLY) {\n            // polygon의 경우, 드래그 되는 좌표에 따라 이벤트 대상 vertex의 x, y 좌표가 자유롭게 변경.\n        }\n\n        vertexCoords = calculateVertexCoords(shapeType, movedCoords);\n\n        return {\n            movedCoords,\n            vertexCoords,\n            grabEl: this.vertexEl\n        };\n    }\n\n    /**\n    * @typedef {\"se\"|\"sw\"|\"ne\"|\"nw\"|\"w\"|\"s\"|\"n\"|\"e\"} module:imageMaps.Direction\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {module:imageMaps.RectCoords} coords\n     * @param {module:imageMaps.Direction} direction\n     * @returns {module:imageMaps.RectCoords}\n     */\n    function getValidCoordsForRect (coords, direction) {\n        let [topLeftX, topLeftY, bottomRightX, bottomRightY] = coords;\n\n        if (bottomRightX - topLeftX <= this.shapeLimitCoords.x) {\n            if (direction === 'se' || direction === 'ne' || direction === 'e') {\n                bottomRightX = topLeftX + this.shapeLimitCoords.x;\n            }\n            if (direction === 'nw' || direction === 'sw' || direction === 'w') {\n                topLeftX = bottomRightX - this.shapeLimitCoords.x;\n            }\n        }\n\n        if (bottomRightY - topLeftY <= this.shapeLimitCoords.y) {\n            if (direction === 'se' || direction === 'sw' || direction === 's') {\n                bottomRightY = topLeftY + this.shapeLimitCoords.y;\n            }\n            if (direction === 'nw' || direction === 'ne' || direction === 'n') {\n                topLeftY = bottomRightY - this.shapeLimitCoords.y;\n            }\n        }\n\n        return [topLeftX, topLeftY, bottomRightX, bottomRightY];\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @this module:imageMaps~ImageMaps\n     * @param {Float} coordsDiff\n     * @returns {Float}\n     */\n    function getValidCoordsForCircle (coordsDiff) {\n        let radius;\n\n        if (coordsDiff <= this.shapeLimitCoords.radius) {\n            ({radius} = this.shapeLimitCoords);\n        } else {\n            radius = coordsDiff;\n        }\n\n        return radius;\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.Coords} coords\n     * @param {module:imageMaps.ShapeType} shapeType\n     * @param {Float} widthRatio\n     * @param {Float} heightRatio\n     * @returns {module:imageMaps.Coords}\n     */\n    function getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n        let adjustCoords = [];\n\n        if (shapeType === SHAPE.RECT || shapeType === SHAPE.IMAGE ||\n            shapeType === SHAPE.ELLIPSE\n        ) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio,\n                coords[3] * heightRatio\n            ];\n        } else if (shapeType === SHAPE.CIRCLE) {\n            let radiusRatio;\n\n            radiusRatio = widthRatio >= heightRatio\n                ? heightRatio\n                : widthRatio;\n\n            if (widthRatio === 1) {\n                radiusRatio = heightRatio;\n            }\n\n            if (heightRatio === 1) {\n                radiusRatio = widthRatio;\n            }\n\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * radiusRatio\n            ];\n        } else if (shapeType === SHAPE.TEXT) {\n            adjustCoords = [\n                coords[0] * widthRatio,\n                coords[1] * heightRatio,\n                coords[2] * widthRatio\n            ];\n        } else if (shapeType === SHAPE.POLY) {\n            // Todo\n        }\n\n        return adjustCoords;\n    }\n\n    /**\n    * @typedef {GenericArray} module:imageMaps.RectCoords\n    * @property {Float} 0\n    * @property {Float} 1\n    * @property {Float} 2\n    * @property {Float} 3\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {module:imageMaps.ShapeElement} shapeEl\n     * @returns {module:imageMaps.RectCoords}\n     */\n    function convertTextToRectCoords (shapeEl) {\n        const bottomLeftX = Number.parseFloat(shapeEl.attr('x'));\n        const bottomLeftY = Number.parseFloat(shapeEl.attr('y'));\n        const shapeSize = shapeEl.get(0).getBBox();\n        const {width} = shapeSize;\n        const height = Number.parseFloat(shapeEl.attr('font-size')) *\n            FONT_SIZE_RATIO / 2;\n\n        return [\n            bottomLeftX,\n            bottomLeftY - height,\n            bottomLeftX + width,\n            bottomLeftY\n        ];\n    }\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {string} [coords]\n     * @returns {?(Float[])}\n     */\n    function convertStringToNumber (coords) {\n        if (!coords) {\n            return null;\n        }\n\n        return [...coords].map((ch) => Number.parseFloat(ch));\n    }\n\n    //   UTIL FUNCTIONS\n\n    /**\n     * GUID: img의 usemap 속성, map의 name 속성을 unique id로 생성.\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @see https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n     * @returns {string}\n     */\n    function guid () {\n        /**\n         * @memberof module:imageMaps.jqueryImageMaps~guid.\n         * @static\n         * @returns {string}\n         */\n        function s4 () {\n            return Math.floor(\n                (1 + Math.random()) * 0x10000\n            ).toString(16).slice(1);\n        }\n        return s4() + s4() + '-' + s4() + '-' + s4() +\n            '-' + s4() + '-' + s4() + s4() + s4();\n    }\n\n    /**\n    * @typedef {PlainObject} module:imageMaps.Dimensions\n    * @property {Float} width\n    * @property {Float} height\n    */\n\n    /**\n     * @memberof module:imageMaps.jqueryImageMaps~\n     * @static\n     * @param {HTMLImageElement|string} imageElOrUrl\n     * @todo If this is to handle an image element, other contexts which use\n     *    the passed in URL should also\n     * @returns {module:imageMaps.Dimensions}\n     */\n    function getNaturalImageSize (imageElOrUrl) {\n        const imageObj = new Image();\n        if (('naturalWidth' in imageObj) && typeof imageElOrUrl !== 'string') {\n            return {\n                width: imageElOrUrl.naturalWidth,\n                height: imageElOrUrl.naturalHeight\n            };\n        }\n        if (typeof imageElOrUrl === 'string') {\n            imageElOrUrl = {src: imageElOrUrl};\n        }\n        imageObj.src = imageElOrUrl.src;\n        return {\n            width: imageObj.width,\n            height: imageObj.height\n        };\n    }\n\n    $.fn.extend({\n        /**\n         * @function external:\"jQuery.fn\".createMaps\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @returns {external:jQuery}\n         */\n        createMaps (coords, linkUrl) {\n            this.data('image_maps_inst').createMaps(coords, linkUrl);\n            return this;\n        },\n\n        /**\n         *\n         * @param {external:jQuery} targetEl\n         * @returns {external:jQuery}\n         */\n        copyImageMapsTo (targetEl) {\n            $.imageMaps.copyImageMaps({\n                shapes: this.getAllShapes(),\n                width: this.width(),\n                height: this.height()\n            }, targetEl);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".addShape\n         * @param {?(module:imageMaps.Coords)} coords\n         * @param {Url} linkUrl\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @returns {external:jQuery}\n         */\n        addShape (coords, linkUrl, shapeType) {\n            this.data('image_maps_inst').addShape(coords, linkUrl, shapeType);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".removeShape\n         * @param {Integer} [index]\n         * @returns {external:jQuery}\n         */\n        removeShape (index) {\n            this.data('image_maps_inst').removeShape(index);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".removeAllShapes\n         * @returns {external:jQuery}\n         */\n        removeAllShapes () {\n            this.data('image_maps_inst').removeAllShapes();\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".destroy\n         * @returns {void}\n         */\n        destroy () {\n            const imageMapsObj = this.data('image_maps_inst');\n            if (!imageMapsObj) {\n                return;\n            }\n\n            imageMapsObj.removeImageMaps();\n            this.data('image_maps_inst', null);\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setShapeStyle\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setShapeStyle (styleOptions) {\n            this.data('image_maps_inst').setShapeStyle(styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setUrl\n         * @param {Url} linkUrl\n         * @param {Integer} index\n         * @returns {external:jQuery}\n         */\n        setUrl (linkUrl, index) {\n            this.data('image_maps_inst').setUrl(linkUrl, index);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setTextShape\n         * @param {string} text\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setTextShape (text, styleOptions) {\n            this.data('image_maps_inst').setTextShape(text, styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".setImageShape\n         * @param {Url} imageUrl\n         * @param {module:imageMaps.ShapeStyles} [styleOptions]\n         * @returns {external:jQuery}\n         */\n        setImageShape (imageUrl, styleOptions) {\n            this.data('image_maps_inst').setImageShape(imageUrl, styleOptions);\n            return this;\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".enableClick\n         * @returns {void}\n         */\n        enableClick () {\n            this.data('image_maps_inst').enableClick();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".disableClick\n         * @returns {void}\n         */\n        disableClick () {\n            this.data('image_maps_inst').disableClick();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".getAllShapes\n         * @returns {module:imageMaps.AllShapeInfo}\n         */\n        getAllShapes () {\n            return this.data('image_maps_inst').getAllShapesInfo();\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".getCoordsByRatio\n         * @param {module:imageMaps.Coords} coords\n         * @param {module:imageMaps.ShapeType} shapeType\n         * @param {Float} widthRatio\n         * @param {Float} heightRatio\n         * @returns {module:imageMaps.Coords}\n         */\n        getCoordsByRatio (coords, shapeType, widthRatio, heightRatio) {\n            return ImageMaps.getCoordsByRatio(\n                coords, shapeType, widthRatio, heightRatio\n            );\n        },\n\n        /**\n         * @function external:\"jQuery.fn\".zoom\n         * @param {Float[]} percentages\n         * @returns {void}\n         */\n        zoom (percentages) {\n            this.data('image_maps_inst').zoom(percentages);\n        }\n    });\n\n    $.imageMaps = {\n        /**\n        * @typedef {PlainObject} module:imageMaps.SourceInfo\n        * @property {module:imageMaps.AllShapeInfo} shapes\n        * @property {Float} width\n        * @property {Float} height\n        */\n        /**\n         * @param {module:imageMaps.SourceInfo} sourceInfo\n         * @param {external:jQuery} targetEl\n         * @returns {void}\n         */\n        copyImageMaps ({shapes, width, height}, targetEl) {\n            targetEl.removeAllShapes();\n            $.each(shapes, (index, item) => {\n                targetEl.setShapeStyle(item.style);\n                if (item.href) {\n                    targetEl.setImageShape(item.href);\n                }\n                if (item.text) {\n                    targetEl.setTextShape(item.text);\n                }\n\n                const widthRatio = width;\n                const heightRatio = height;\n                const newCoords = getCoordsByRatio(\n                    item.coords,\n                    item.type,\n                    targetEl.width() / widthRatio,\n                    targetEl.height() / heightRatio\n                );\n                targetEl.addShape(newCoords, item.url, item.type);\n            });\n        }\n    };\n\n    /**\n     * @function external:\"jQuery.fn\".imageMaps\n     * @this external:jQuery\n     * @param {module:imageMaps.ImageMapOptions} [options]\n     * @throws {Error}\n     * @returns {module:imageMaps.ImageMaps|void}\n     */\n    $.fn.imageMaps = function (options) {\n        if (this.length === 1) {\n            if (!this.data('image_maps_inst')) {\n                const imageMapsInst = new ImageMaps(this, options);\n                this.data('image_maps_inst', imageMapsInst);\n                return imageMapsInst;\n            }\n            return this.data('image_maps_inst');\n        }\n        if (this.length > 1) {\n            throw new Error('imageMaps instance has already been created.');\n        }\n        return undefined;\n    };\n    return $;\n}\n\nexport default jqueryImageMaps;\n"],"names":["shapeFaceClass","shapeVertexClass","areaClass","SHAPE","defaults","isEditMode","shape","shapeText","shapeStyle","fill","stroke","onClick","e","targetAreaHref","onMouseDown","shapeType","coords","onMouseMove","movedCoords","onMouseUp","updatedCoords","onSelect","shapeInfo","defaultShapeOptions","NS_SVG","NS_XLINK","$","ImageMaps","container","options","mapEl","svgEl","extend","this","shapeImageUrl","shapeCoords","vertexCoords","grabType","containerWidth","containerHeight","touchStartCoords","x","y","dragInfo","face","vertex","shapeLimitCoords","radius","allShapeInfo","linkUrl","imageWidth","width","Number","isNaN","one","proxy","createMaps","call","styleOptions","index","text","setShapeStyle","imageUrl","setShapeType","shapeEl","data","areaEl","find","detachEvents","type","parent","remove","removeShapeInfo","each","i","_this","removeShape","removeAllShapes","shapeOptions","shapeSecondaryOptions","percentages","zoom","attachEvents","handler","onTouchStart","onClickShapeFace","element","vertexEl","elements","vertexEls","eventOptions","forEach","on","_this2","eventType","eventHandler","_this3","off","uid","s4","Math","floor","random","toString","slice","guid","attr","usemapName","replace","insertAfter","height","imageHeight","centerX","centerY","isDefaultTextCoords","_toConsumableArray","map","ch","parseFloat","convertStringToNumber","Array","isArray","defaultShapeX","defaultShapeY","defaultRadius","imageSize","imageElOrUrl","imageObj","Image","naturalWidth","naturalHeight","src","getNaturalImageSize","length","areaType","href","createOverlay","setShapeCoords","updateShapeInfo","url","style","adjustTextShape","createArea","document","createElementNS","svgNativeEl","get","window","onResize","setAttribute","containerPos","position","xmlns","version","css","zIndex","overflow","top","left","shapeGroupEl","createShape","append","join","appendTo","gEl","drawShape","cursor","setShapeElement","calculateVertexCoords","vertexTemp","drawVertex","createVertex","setVertexElements","setAttributeNS","cx","cy","getBBox","resultX","parseInt","resultY","eachCoords","vertexArr","drawArea","bottomLeftX","bottomLeftY","convertTextToRectCoords","touchCoords","originalEvent","touches","pageX","pageY","targetAreaEl","currentTarget","tagName","toLowerCase","preventDefault","target","changedTouches","open","targetEl","getShapeInfo","targetX","targetY","setImageShape","setVertexCoords","push","is","declareShape","declareVertex","determineShape","movedX","movedY","getMovedShapeCoords","getMovedVertexCoords","offset","grabEl","abs","redraw","widthPercentage","heightPercentage","setTimeout","_this4","widthRatio","heightRatio","item","getCoordsByRatio","_this5","setVertexElement","vertexIndex","idx","direction","getValidCoordsForRect","console","warn","getValidCoordsForCircle","topLeftX","topLeftY","bottomRightX","bottomRightY","coordsDiff","adjustCoords","radiusRatio","fn","copyImageMapsTo","imageMaps","copyImageMaps","shapes","getAllShapes","addShape","destroy","imageMapsObj","removeImageMaps","setUrl","setTextShape","enableClick","disableClick","getAllShapesInfo","newCoords","imageMapsInst","Error"],"mappings":"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"}